# 一、GPIO概述

<div><img src="https://cdn.jsdelivr.net/gh/lcekold/blogimage@main/Network/Snipaste_2025-03-06_21-49-03.png"></div>


## 1.1 输入

<div><img src="https://cdn.jsdelivr.net/gh/lcekold/blogimage@main/Network/Snipaste_2025-03-06_21-49-48.png"></div>

在图中我们可以看到被输出控制模块控制的两个MOS，分别是P-MOS和N-MOS，其作用可以被简化为两个被控制的开关。VDD是指3.3V的高电平，VSS是指0V的低电平。

STM32的输出分为两类，推挽输出和开漏输出。

### 1.1.1 推挽输出
我们先假设I/O连接了一个小灯，小灯的另一端是GND，倘若小灯的工作电压为3.3V，则我们可以使用推挽输出模式，此模式下P-MOS和N-MOS协同工作。

当我们使用HAL_GPIO_WritePin函数控制此I/O口输出高电平，函数内部对相关寄存器的数据进行了修改，导致P-MOS激活，N-MOS关闭，此时VDD与I/O引脚连通，输出高电平，电流形成，小灯亮起。

当我们控制I/O口输出低电平时则相反，P-MOS关闭，N-MOS激活，VSS连接到I/O引脚，对外输出0V的低电平，没有电流产生，小灯也就熄灭，这就是推挽输出的工作方式。其具有一定的电压与电流驱动能力。可以直接驱动一些合适的元件工作。

### 1.1.2 开漏输出
但总有一些元件需要更高或者更低的电压来驱动，例如倘若小灯的工作电压为5V，则由推挽输出提供的3.3V高电平就无法正常将其驱动，此时就是开漏输出的用武之地。

开漏模式下只有N-MOS工作，P-MOS一直处于断开状态。使用HAL_GPIO_WritePin函数控制I/O口输出高电平，则N-MOS断开，整个I/O口内部处于高阻态，或者说“断路”,并不对外输出特定的电平信号，电路断路，小灯也就不会亮起。

若控制I/O口输出低电平，则N-MOS激活，I/O引脚与VSS连接，小灯两端都是0V，也不会亮起。

但倘若我们将小灯的GND改为来自外部的5V，则此时电压差形成，电流产生，小灯亮起，而再让I/O口输出高电平，也就是N-MOS断开，依旧形成断路，也就无法产生电流，小灯熄灭，这样我们在开漏模式下也就可以正常控制小灯亮灭了。

可以看到推挽输出时，小灯是由来自芯片的电压所驱动。但开漏输出并没有驱动能力，必须依靠外部的电压源来进行驱动，这是其缺点，但也因此成为了最大的优点，更加灵活。

这里需要提醒的是，我们需要使用支持5V容忍的I/O口，否则会使上方保护二极管长期导通，将5V引入电源中，造成损坏

### 1.1.3 总结

<div><img src="https://cdn.jsdelivr.net/gh/lcekold/blogimage@main/Network/Snipaste_2025-03-06_22-05-14.png"></div>

<div><img src="https://cdn.jsdelivr.net/gh/lcekold/blogimage@main/Network/Snipaste_2025-03-06_22-05-59.png"></div>

此外，我们可以看到对于输出控制模块来说，它有两个控制指令的来源，一个是我们使用HAL_GPIO_WritePin函数控制的输出寄存器，而另一个则是我们后面将会学习的片上外设，例如串口模块，I2C模块等，由于同时控制会导致输出控制模块不知道听谁的，因此根据控制来源的不同，STM将两种输出模式又细分为了，普通的推挽输出与开漏输出以及复用推挽输出与复用开漏输出。

## 1.2 输入

<div><img src="https://cdn.jsdelivr.net/gh/lcekold/blogimage@main/Network/Snipaste_2025-03-06_22-17-57.png"></div>

外部输入的电流从I/O引脚进入后，首先经过的是一对上拉下拉电阻，当我们设置上拉输入时，上拉电阻启用，设置下拉输入时，下拉电阻启用，而浮空输入时，两个电阻都不会启动，与开漏输出类似，可以依赖外部的电路实现更多可能性，电流继续前进会遇到一个TTL肖特基触发器，或者说施密特触发器，其作用是稳定电平。

<div><img src="https://cdn.jsdelivr.net/gh/lcekold/blogimage@main/Network/Snipaste_2025-03-06_22-20-33.png"></div>

当输入电压高于高参考电压则输出高电平，当输入电压低于低参考电压则输出低电平。在两者之间则维持原本的电平信号不变。

最后经过施密特触发器处理后的电平信号被写入输入数据寄存器，等待我们使用HAL_GPIO_ReadPin函数对寄存器进行读取，这就是中最基本的GPIO口读取高低电平的原理。

不过我们可以看到，在这条主线当中有两个分支，第一条分支通向了模拟输入，浮空、上拉、下拉这三种输入模式都是仅读取了高低电平，也就是所谓的数字信号，因而我们统称为数字信号，而模拟信号却是读取输入电压的具体值，因而其在施密特触发器前便产生了分支，将电压引入了模拟输入相关的片上外设，具体使用模拟输入读取到I/O引脚的电压值，我们将在ADC相关知识中学到。

而另一条支线则在施密特触发器之后，接入了例如串口模块等需要数字输入的片上外设，不过与输出部分只能有一个控制源不同的是，输入部分的不同分支可以同时读取施密特触发器的输出，也就没有出现什么复用上拉输入等模式，而是在片上外设上也使用普通的输入模式即可。